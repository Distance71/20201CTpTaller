Modelo proyecto taller 1

Extras:


Game provider: Sirve para obtener variables globales
Logger: Registrará todo lo que ocurre en la aplicación en un archivo de texto dependiendo del nivel que se establezca
Graphics:  encarga de todo lo que es graficar. Veremos que clases extras necesitará y como utilizar


EL JUEGO EN SI
Game


La evolución del juego será organizada y manejada por la clase Game

Las tareas de dichas clase serán:
•	Inicializar Logger 
•	Inicializar gráficos
•	Inicializar menú principal
•	Capturar instrucciones
•	Procesar eventos
•	Actualizar estados
•	Actualizar gráficos

Scoreboard: Deberia ser un objeto que cuenta la puntuación del jugador, depende a lo que sucede en el juego se incrementa(o se disminuye si se les ocurre a los profes que algo lo disminuya). Se podría incluso manejar multiplicadores de puntos  y cualquier cosa que se les ocurra después directo desde aca
Atributos: points
Métodos: increase(int o float)
	      get score
	   

Map: Será un con conjunto de celdas, Se lo puede implementar como una lista ( o como una lista de listas) donde cada posición contiene un objeto del tipo celda
La cantidad de celdas la definiremos por defecto. 
Metódos:
Insert_element_in position(MapElement,Position)-> Se debe controlar que el mapelement no esté en el mapa previamente
Move_element(Mapelement ID,direction): Como el objeto que esta en la celda es un mapelement, el mapa se encargará de averiguar su velocidad y moverlo tantos casilleros como su velocidad lo indique en la dirección definida

Cell: Es una posición en el mapa. Una celda puede contener únicamente MapElements.
Metodos: is_empty
	     Get_item
	     Insert(MapElement)
	     Clean()

Enemymanager: Se encarga del control de la aparición de enemigos en el mapa y de su manejo, propongo que tenga como atributo un nivel y dependiendo el nivel coloque en el mapa más cantidad de enemigos, aumente su poder, aumente su vida o cambie la clase se enemigos que aparecen. Le indica al action controller la acción que los enemigos deben hacer (pasándole el id y la acción)

Insructionreader(ID nave): Lee las instrucciones ingresadas por teclado por el usuario. Cada  tecla del teclado tendrá  asignada en un archivo una instrucción que el  instruction reader le indicará al actioncontroller que la nave debe realizar( pasándole el ID y la acción).
Ejemplo del archivo( podría ser incluso un csv):
Key  action
X        shoot
ActionController(ID,Accion): Obtiene del mapa el elemento con el ID deseado y le hace
Realizar la acción.


MapElement: Cualquier elemento del mapa. Tiene como atributos:
-String: ID
-int:damage
-speed
-Orientation orientación  Tendríamos un objeto del tipo orientación, al cual le podríamos decir girate y cosas asi
-int life

Todo elemento del mapa puede realizar los siguientes métodos o acciones:
rotate
get_damage(recibir daño)
decrease_life(disminuir vida)
get_id
is_dead(me permite saber si esta muerto o no)
get_state()
get_speed
get_orientation


Heredan de map element:
Nave: Es la nave principal del juego
Métodos adicionales a los demás:
Shoot: (Disparar): Genera en su posición un nuevo Mapelement bala de vida casi nula y un determinado daño.
-OTRAS COSAS QUE AGREGUEN DESPUES, POR EJEMPLO AUMENTAR SU VIDA Y COSAS ASI

Bala: Le pasa por parámetro el daño y la orientación en la cual se tiene que mover. El objeto bala estará en el mapa hasta que colisione con otro objeto o se salga del mismo. El objeto se mueve en línea recta desde el punto en que se crea en la orientación pasada por parámetro. EN PRINCIPIO SERIAN LAS BALAS DE LA NAVE PRINCIPAL, SI HAY OTRO TIPO DESPUES SE VERÁ

Veremos depende lo que hagan los enemigos que cosas tienen que tener


#VER MANEJO DE ERRORS:
CUALQUIER ERROR FATAL LANZA UN MENSAJE CIERRA EL JUEGO 
CUALQUIER ERROR DE PROGRAMACION SE TRABAJARIA CON MANEJO DE EXCEPCIONES


#SI DOS OBJETOS COLISIONAN, EN PRINCIPIO SE HACEN DAÑO DEPUES CONTROLAEREMOS QUE PASA SI SON DEL MISMO BANDO, NO SERIA UN PROBLEMA